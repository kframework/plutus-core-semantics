<T>
  <plutus>
    .
  </plutus>
  <iele>
    .TopLevelDefinitions
  </iele>
  <ieleContract>
    contract Foo {
      define public @sixArg ( .LocalNames ) {
        %fresh12 , .LValues = call @alloc ( 1 , .Operands )
        store 13 , %fresh12
        %fresh10 , .LValues = call @dispatch ( %fresh12 , 2 , .Operands )
        %fresh8 , .LValues = call @dispatch ( %fresh10 , 3 , .Operands )
        %fresh6 , .LValues = call @dispatch ( %fresh8 , 5 , .Operands )
        %fresh4 , .LValues = call @dispatch ( %fresh6 , 7 , .Operands )
        %fresh2 , .LValues = call @dispatch ( %fresh4 , 11 , .Operands )
        %ret , .LValues = call @dispatch ( %fresh2 , 13 , .Operands )
        ret %ret , .Operands
        .Instructions .LabeledBlocks
      }
      
      define @fresh13 ( %x , %y , %z , %a , %b , %c , .LocalNames ) {
        %fresh15 = mul %z , %a
        %ret = add %c , %fresh15
        ret %ret , .Operands
        .Instructions .LabeledBlocks
      }
      
      define @dispatch ( %closure , %param , .LocalNames ) {
        %closureId = load %closure
        %cond = cmp eq %closureId , 3333
        br %cond , call13
        %cond = cmp eq %closureId , -1
        br %cond , call0
        %ret , .LValues = call @appendArg ( %closure , %closureId , %param , .Operands )
        ret %ret , .Operands

        call0:
        call @iele.invalid ( .Operands )

        call13:
        %closure = add %closure , 1
        %param1 = load %closure
        %closure = add %closure , 1
        %param2 = load %closure
        %closure = add %closure , 1
        %param3 = load %closure
        %closure = add %closure , 1
        %param4 = load %closure
        %closure = add %closure , 1
        %param5 = load %closure
        %ret , .LValues = call @fresh13 ( %param1 , %param2 , %param3 , %param4 , %param5 , %param , .Operands )
        ret %ret , .Operands
        .Instructions .LabeledBlocks
      }
      
      define @alloc ( %size , .LocalNames ) {
        %alloc_counter_ptr = 0
        %alloced = load %alloc_counter_ptr
        %isInitialized = cmp gt 0 , %alloced
        br %isInitialized , initialized
        %alloced = 1

        initialized:
        %ret = %alloced
        %alloced = add %size , %alloced
        store %alloced , %alloc_counter_ptr
        ret %ret , .Operands
        .Instructions .LabeledBlocks
      }
      
      define @appendArg ( %closure , %closureId , %param , .LocalNames ) {
        %numParams = load %closure , 1 , 1
        %numParams = add %numParams , 1
        %spaceNeeded = add %numParams , 1
        %ret , .LValues = call @alloc ( %spaceNeeded , .Operands )

        // "Location in returned closure to write to"
        %writeAddr = %ret

        // "Copy closure ID"
        store %closureId , %writeAddr

        // "Update number of parameters"
        store %numParams , %writeAddr , 1 , 1

        // "Copy arguments one at a time"

        while:
        %numParams = sub %numParams , 1
        %cond = cmp eq %numParams , 0
        br %cond , done
        %writeAddr = add %writeAddr , 1
        %closure = add %closure , 1
        %v = load %closure
        store %v , %writeAddr
        br while

        done:

        // "Add new parameter"
        %writeAddr = add %writeAddr , 1
        store %param , %writeAddr
        ret %ret , .Operands
        .Instructions .LabeledBlocks
      }
      
      .TopLevelDefinitions
    }
  </ieleContract>
  <totalFunctions>
    3
  </totalFunctions>
  <totalReadyForDispatch>
    3
  </totalReadyForDispatch>
  <dispatchedFunctionsLeft>
    0
  </dispatchedFunctionsLeft>
  <exports>
    sixArg  .QualCList
  </exports>
  <functions>
    .FunctionCellSet
  </functions>
</T>
