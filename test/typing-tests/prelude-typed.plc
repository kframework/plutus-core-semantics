(program
(module Prelude
    (imported)
    (exported () ())
    (local () ())


    //
    // Function Tools
    //
    
    (declare id (forall a (type) (fun a a)))
    (define id
      (abs a (lam x x)))
    
    
    (declare const
      (forall a (type) (forall b (type)
        (fun a (fun b a)))))
    (define const
      (abs a (abs b
        (lam x (lam y x)))))
    
    
    (declare flip
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun b (fun a c)))))))
    (define flip
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f y x])))))))
    
    
    (declare applyTo
      (forall a (type) (forall b (type)
        (fun a (fun (fun a b) b)))))
    (define applyTo
      (abs a (abs b
        (lam x (lam f
          [f x])))))
    
    
    (declare compose
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun b c)
             (fun (fun a b)
                  (fun a c)))))))
    (define compose
      (abs a (abs b (abs c
        (lam f (lam g (lam x
          [f [g x]])))))))
    
    
    (declare compose2
      (forall a (type) (forall b (type) (forall c (type) (forall d (type)
        (fun (fun c d)
             (fun (fun a (fun b c))
                  (fun a (fun b d)))))))))
    (define compose2
      (abs a (abs b (abs c (abs d
        (lam f (lam g (lam x (lam y
          [f [g x y]])))))))))
    
    
    
    //
    // Unit Tools
    //
    
    (data Unit () (MkUnit))
    
    
    
    //
    // Pair Tools
    //
    
    (data Pair ((a (type)) (b (type)))
          (MkPair a b))
    
    
    (declare fst
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b) a))))
    (define fst
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y) x))))))
    
    
    (declare snd
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b) b))))
    (define snd
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y) y))))))
    
    
    (declare curry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun (con Prelude.Pair a b) c)
             (fun a (fun b c)))))))
    (define curry
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f (con Prelude.MkPair x y)])))))))
    
    
    (declare uncurry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun (con Prelude.Pair a b) c))))))
    (define uncurry
      (abs a (abs b (abs c
        (lam f (lam p
          (case p
            (Prelude.MkPair (x y) [f x y]))))))))
    
    
    (declare swap
      (forall a (type) (forall b (type)
        (fun (con Prelude.Pair a b)
             (con Prelude.Pair b a)))))
    (define swap
      (abs a (abs b
        (lam p
          (case p
            (Prelude.MkPair (x y)
              (isa (con Prelude.MkPair y x)
                   (con Prelude.Pair b a))))))))
    
    
    
    //
    // Boolean Tools
    //
    
    (data Bool () (True) (False))
    
    
    (declare not
      (fun (con Prelude.Bool) (con Prelude.Bool)))
    (define not
      (lam x
        (case x
          (Prelude.True ()
            (isa (con Prelude.False)
                 (con Prelude.Bool)))
          (Prelude.False ()
            (isa (con Prelude.True)
                 (con Prelude.Bool))))))
    
    
    (declare and
      (fun (con Prelude.Bool)
           (fun (con Prelude.Bool)
                (con Prelude.Bool))))
    (define and
      (lam x (lam y
        (case x
          (Prelude.True () y)
          (Prelude.False ()
            (isa (con Prelude.False)
                 (con Prelude.Bool)))))))
    
    
    (declare or
      (fun (con Prelude.Bool)
           (fun (con Prelude.Bool)
                (con Prelude.Bool))))
    (define or
      (lam x (lam y
        (case x
          (Prelude.True ()
            (isa (con Prelude.True)
                 (con Prelude.Bool)))
          (Prelude.False () x)))))
    
    
    (declare bool
      (forall a (type)
        (fun a (fun a (fun (con Prelude.Bool) a)))))
    (define bool
      (abs a
        (lam f (lam t (lam b
          (case b
            (Prelude.True  () t)
            (Prelude.False () f)))))))
    
    
    
    //
    // Integer Tools
    //
    
    (declare addInteger
      (fun (integer) (fun (integer) (integer))))
    (define addInteger
      (lam x (lam y
        (builtin addInteger x y))))
    
    
    (declare subtractInteger
      (fun (integer) (fun (integer) (integer))))
    (define subtractInteger
      (lam x (lam y
        (builtin subtractInteger x y))))
    
    
    (declare multiplyInteger
      (fun (integer) (fun (integer) (integer))))
    (define multiplyInteger
      (lam x (lam y
        (builtin multiplyInteger x y))))
    
    
    (declare divideInteger
      (fun (integer) (fun (integer) (integer))))
    (define divideInteger
      (lam x (lam y
        (builtin divideInteger x y))))
    
    
    (declare remainderInteger
      (fun (integer) (fun (integer) (integer))))
    (define remainderInteger
      (lam x (lam y
        (builtin remainderInteger x y))))
    
    
    (declare equalsInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define equalsInteger
      (lam x (lam y
        (builtin equalsInteger x y))))
    
    
    (declare lessThanInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define lessThanInteger
      (lam x (lam y
        (builtin lessThanInteger x y))))
    
    
    (declare lessThanEqualsInteger
      (fun (integer) (fun (integer) (con Prelude.Bool))))
    (define lessThanEqualsInteger
      (lam x (lam y
        (builtin lessThanEqualsInteger y x))))
    
    
    (declare maxInteger
      (fun (integer) (fun (integer) (integer))))
    (define maxInteger
      (lam x (lam y
        (case [Prelude.lessThanInteger x y]
          (Prelude.True () y)
          (Prelude.False () x)))))
    
    
    (declare minInteger
      (fun (integer) (fun (integer) (integer))))
    (define minInteger
      (lam x (lam y
        (case [Prelude.lessThanInteger x y]
          (Prelude.True () x)
          (Prelude.False () y)))))
    
    
    // (declare integerToFloat
    //   (fun (integer) (float)))
    // (define integerToFloat
    //   (lam x
    //     (builtin integerToFloat x)))
    
    
    (declare integerToByteString
      (fun (integer) (bytestring)))
    (define integerToByteString
      (lam x
        (builtin integerToByteString x)))
    
    
    
    //
    // Float Tools
    //
    
    // (declare addFloat
    //   (fun (float) (fun (float) (float))))
    // (define addFloat
    //   (lam x (lam y
    //     (builtin addFloat x y))))
    
    
    // (declare subtractFloat
    //   (fun (float) (fun (float) (float))))
    // (define subtractFloat
    //   (lam x (lam y
    //     (builtin subtractFloat x y))))
    
    
    // (declare multiplyFloat
    //   (fun (float) (fun (float) (float))))
    // (define multiplyFloat
    //   (lam x (lam y
    //     (builtin multiplyFloat x y))))
    
    
    // (declare divideFloat
    //   (fun (float) (fun (float) (float))))
    // (define divideFloat
    //   (lam x (lam y
    //     (builtin divideFloat x y))))
    
    
    // (declare equalsFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define equalsFloat
    //   (lam x (lam y
    //     (builtin equalsFloat x y))))
    
    
    // (declare lessThanFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define lessThanFloat
    //   (lam x (lam y
    //     (builtin lessThanFloat x y))))
    
    
    // (declare lessThanEqualsFloat
    //   (fun (float) (fun (float) (con Prelude.Bool))))
    // (define lessThanEqualsFloat
    //   (lam x (lam y
    //     (builtin lessThanEqualsFloat y x))))
    
    
    // (declare ceil
    //   (fun (float) (integer)))
    // (define ceil
    //   (lam x
    //     (builtin ceil x)))
    
    
    // (declare floor
    //   (fun (float) (integer)))
    // (define floor
    //   (lam x
    //     (builtin floor x)))
    
    
    // (declare maxFloat
    //   (fun (float) (fun (float) (float))))
    // (define maxFloat
    //   (lam x (lam y
    //     (case [Prelude.lessThanFloat x y]
    //       (Prelude.True () y)
    //       (Prelude.False () x)))))
    
    
    // (declare minFloat
    //   (fun (float) (fun (float) (float))))
    // (define minFloat
    //   (lam x (lam y
    //     (case [Prelude.lessThanFloat x y]
    //       (Prelude.True () x)
    //       (Prelude.False () y)))))
    
    
    
    //
    // ByteString Tools
    //
    
    (declare concatenate
      (fun (bytestring) (fun (bytestring) (bytestring))))
    (define concatenate
      (lam x (lam y
        (builtin concatenate x y))))
    
    
    (declare takeByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define takeByteString
      (lam n (lam x
        (builtin takeByteString n x))))
    
    
    (declare dropByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define dropByteString
      (lam n (lam x
        (builtin dropByteString n x))))
    
    
    (declare sha2_256
      (fun (bytestring) (bytestring)))
    (define sha2_256
      (lam x
        (builtin sha2_256 x)))
    
    
    (declare sha3_256
      (fun (bytestring) (bytestring)))
    (define sha3_256
      (lam x
        (builtin sha3_256 x)))
    
    
    (declare equalsByteString
      (fun (bytestring) (fun (bytestring) (con Prelude.Bool))))
    (define equalsByteString
      (lam x (lam y
        (builtin equalsByteString x y))))
    
    
    
    //
    // Maybe Tools
    //
    
    (data Maybe ((a (type)))
          (Nothing)
          (Just a))
    
    
    (declare maybe
      (forall a (type) (forall b (type)
        (fun b (fun (fun a b) (fun (con Prelude.Maybe a) b))))))
    (define maybe
      (abs a (abs b
        (lam n (lam j (lam m
          (case m
            (Prelude.Nothing () n)
            (Prelude.Just (x) [j x]))))))))
    
    
    (declare isJust
      (forall a (type)
        (fun (con Prelude.Maybe a) (con Prelude.Bool))))
    (define isJust
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.False)
                   (con Prelude.Bool)))
            (Prelude.Just (x)
              (isa (con Prelude.True)
                   (con Prelude.Bool)))))))
    
    
    (declare isNothing
      (forall a (type)
        (fun (con Prelude.Maybe a) (con Prelude.Bool))))
    (define isNothing
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.True)
                   (con Prelude.Bool)))
            (Prelude.Just (x)
              (isa (con Prelude.False)
                   (con Prelude.Bool)))))))
    
    
    (declare fromMaybe
      (forall a (type)
        (fun a (fun (con Prelude.Maybe a) a))))
    (define fromMaybe
      (abs a
        (lam n (lam m
          (case m
            (Prelude.Nothing () n)
            (Prelude.Just (x) x))))))
    
    
    (declare mapMaybe
      (forall a (type) (forall b (type)
        (fun (fun a b)
             (fun (con Prelude.Maybe a)
                  (con Prelude.Maybe b))))))
    (define mapMaybe
      (abs a (abs b
        (lam f (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe b)))
            (Prelude.Just (x)
              (isa (con Prelude.Just [f x])
                   (con Prelude.Maybe b)))))))))
    
    
    (declare equalsMaybe
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (con Prelude.Maybe a)
            (fun (con Prelude.Maybe a)
              (con Prelude.Bool))))))
    (define equalsMaybe
      (abs a (lam eq (lam m (lam m'
        (case m
          (Prelude.Nothing ()
            (case m'
              (Prelude.Nothing ()
                (isa (con Prelude.True)
                     (con Prelude.Bool)))
              (Prelude.Just (y)
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Just (x)
            (case m'
              (Prelude.Nothing ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Just (y) [eq x y])))))))))
    
    
    
    //
    // Either Tools
    //
    
    (data Either ((a (type)) (b (type)))
          (Left a)
          (Right b))
    
    
    (declare either
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a c)
             (fun (fun b c)
                  (fun (con Prelude.Either a b) c)))))))
    (define either
      (abs a (abs b (abs c
        (lam f (lam g (lam e
          (case e
            (Prelude.Left (x) [f x])
            (Prelude.Right (y) [g y])))))))))
    
    
    (declare isLeft
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b) (con Prelude.Bool)))))
    (define isLeft
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.True)
                   (con Prelude.Bool)))
            (Prelude.Right (y)
              (isa (con Prelude.False)
                   (con Prelude.Bool))))))))
    
    
    (declare isRight
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b) (con Prelude.Bool)))))
    (define isRight
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.False)
                   (con Prelude.Bool)))
            (Prelude.Right (y)
              (isa (con Prelude.True)
                   (con Prelude.Bool))))))))
    
    
    (declare eitherToMaybe
      (forall a (type) (forall b (type)
        (fun (con Prelude.Either a b)
             (con Prelude.Maybe b)))))
    (define eitherToMaybe
      (abs a (abs b
        (lam e
          (case e
            (Prelude.Left (x)
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe b)))
            (Prelude.Right (y)
              (isa (con Prelude.Just y)
                   (con Prelude.Maybe b))))))))
    
    
    (declare maybeToEither
      (forall a (type) (forall b (type)
        (fun a
          (fun (con Prelude.Maybe b)
               (con Prelude.Either a b))))))
    (define maybeToEither
      (abs a (abs b
        (lam x (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.Left x)
                   (con Prelude.Either a b)))
            (Prelude.Just (y)
              (isa (con Prelude.Right y)
                   (con Prelude.Either a b)))))))))
    
    
    (declare equalsEither
      (forall a (type) (forall b (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (fun b (fun b (con Prelude.Bool)))
            (fun (con Prelude.Either a b)
              (fun (con Prelude.Either a b)
                (con Prelude.Bool))))))))
    (define equalsEither
      (abs a (abs b (lam eqA (lam eqB (lam e (lam e'
        (case e
          (Prelude.Left (x)
            (case e'
              (Prelude.Left (x') [eqA x x'])
              (Prelude.Right (y')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Right (y)
            (case e'
              (Prelude.Left (x')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Right (y') [eqB y y'])))))))))))
    
    
    
    //
    // List Tools
    //
    
    (data List ((a (type)))
          (Nil)
          (Cons a (con Prelude.List a)))
    
    
    (declare equalsList
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
          (fun (con Prelude.List a)
            (fun (con Prelude.List a)
              (con Prelude.Bool))))))
    (define equalsList
      (abs a (lam eqA (lam xs (lam ys
        (case xs
          (Prelude.Nil ()
            (case ys
              (Prelude.Nil ()
                (isa (con Prelude.True)
                     (con Prelude.Bool)))
              (Prelude.Cons (y ys')
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.Cons (x xs')
            (case ys
              (Prelude.Nil ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.Cons (y ys')
                [Prelude.and
                  [eqA x y]
                  [(inst Prelude.equalsList a) eqA xs' ys']])))))))))
    
    
    (declare append
      (forall a (type)
        (fun (con Prelude.List a)
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define append
      (abs a
        (lam xs (lam ys
          (case xs
            (Prelude.Nil () ys)
            (Prelude.Cons (x xs')
              (isa (con Prelude.Cons
                     x
                     [(inst Prelude.append a) xs' ys])
                   (con Prelude.List a))))))))
    
    
    (declare head
      (forall a (type)
        (fun (con Prelude.List a) (con Prelude.Maybe a))))
    (define head
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe a)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Just x)
                   (con Prelude.Maybe a)))))))
    
    
    (declare last
      (forall a (type)
        (fun (con Prelude.List a) (con Prelude.Maybe a))))
    (define last
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe a)))
            (Prelude.Cons (x xs')
              (case xs'
                (Prelude.Nil ()
                  (isa (con Prelude.Just x)
                       (con Prelude.Maybe a)))
                (Prelude.Cons (x' xs'')
                  [(inst Prelude.last a)
                    (con Prelude.Cons x' xs'')])))))))
    
    
    (declare tail
      (forall a (type)
        (fun (con Prelude.List a)
             (con Prelude.Maybe (con Prelude.List a)))))
    (define tail
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe (con Prelude.List a))))
            (Prelude.Cons (x xs)
              (isa (con Prelude.Just xs)
                   (con Prelude.Maybe (con Prelude.List a))))))))
    
    
    (declare init
      (forall a (type)
        (fun (con Prelude.List a)
             (con Prelude.Maybe (con Prelude.List a)))))
    (define init
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe (con Prelude.List a))))
            (Prelude.Cons (x xs)
              (case [(inst Prelude.init a) xs]
                (Prelude.Nothing ()
                  (isa (con Prelude.Just (con Prelude.Nil))
                       (con Prelude.Maybe (con Prelude.List a))))
                (Prelude.Just (ys)
                  (isa (con Prelude.Just (con Prelude.Cons x ys))
                       (con Prelude.Maybe (con Prelude.List a))))))))))
    
    
    (declare uncons
      (forall a (type)
        (fun (con Prelude.List a)
             (con Prelude.Maybe (con Prelude.Pair a (con Prelude.List a))))))
    (define uncons
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe
                     (con Prelude.Pair a (con Prelude.List a)))))
            (Prelude.Cons (x xs)
              (isa (con Prelude.Just (con Prelude.MkPair x xs))
                   (con Prelude.Maybe
                     (con Prelude.Pair a (con Prelude.List a)))))))))
    
    
    (declare null
      (forall a (type)
        (fun (con Prelude.List a) (con Prelude.Bool))))
    (define null
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.True)
                   (con Prelude.Bool)))
            (Prelude.Cons (x xs)
              (isa (con Prelude.False)
                   (con Prelude.Bool)))))))
    
    
    (declare length
      (forall a (type)
        (fun (con Prelude.List a) (integer))))
    (define length
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil () 0)
            (Prelude.Cons (x xs)
              [Prelude.addInteger 1
                [(inst Prelude.length a) xs]])))))
    
    
    (declare take
      (forall a (type)
        (fun (integer)
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define take
      (abs a
        (lam n (lam xs
          (case [Prelude.equalsInteger n 0]
            (Prelude.True ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.False ()
              (case xs
                (Prelude.Nil ()
                  (isa (con Prelude.Nil)
                       (con Prelude.List a)))
                (Prelude.Cons (x xs')
                  (isa
                    (con Prelude.Cons
                      x
                      [(inst Prelude.take a)
                        [Prelude.subtractInteger n 1] xs'])
                    (con Prelude.List a))))))))))
    
    
    (declare drop
      (forall a (type)
        (fun (integer)
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define drop
      (abs a
        (lam n (lam xs
          (case [Prelude.equalsInteger n 0]
            (Prelude.True () xs)
            (Prelude.False ()
              (case xs
                (Prelude.Nil ()
                  (isa (con Prelude.Nil)
                       (con Prelude.List a)))
                (Prelude.Cons (x xs')
                  [(inst Prelude.drop a)
                    [Prelude.subtractInteger n 1]
                    xs']))))))))
    
    
    (declare splitAt
      (forall a (type)
        (fun (integer)
             (fun (con Prelude.List a)
                  (con Prelude.Pair
                       (con Prelude.List a)
                       (con Prelude.List a))))))
    (define splitAt
      (abs a
        (lam n (lam xs
          (case [Prelude.equalsInteger n 0]
            (Prelude.True ()
              (isa (con Prelude.MkPair (con Prelude.Nil) xs)
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List a))))
            (Prelude.False ()
              (case xs
                (Prelude.Nil ()
                  (isa (con Prelude.MkPair
                            (con Prelude.Nil)
                            (con Prelude.Nil))
                       (con Prelude.Pair
                            (con Prelude.List a)
                            (con Prelude.List a))))
                (Prelude.Cons (x xs')
                  (case [(inst Prelude.splitAt a)
                          [Prelude.subtractInteger n 1] xs']
                    (Prelude.MkPair (ys zs)
                      (isa (con Prelude.MkPair
                                (con Prelude.Cons x ys) zs)
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a)))))))))))))
    
    
    (declare takeWhile
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define takeWhile
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (isa
                    (con Prelude.Cons
                      x
                      [(inst Prelude.takeWhile a) p xs'])
                    (con Prelude.List a)))
                (Prelude.False ()
                  (isa (con Prelude.Nil)
                       (con Prelude.List a))))))))))
    
    
    (declare dropWhile
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define dropWhile
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil () 
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  [(inst Prelude.dropWhile a) p xs'])
                (Prelude.False ()
                  (isa (con Prelude.Cons x xs')
                       (con Prelude.List a))))))))))
    
    
    (declare span
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Pair
                    (con Prelude.List a)
                    (con Prelude.List a))))))
    (define span
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.MkPair
                        (con Prelude.Nil)
                        (con Prelude.Nil))
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List a))))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (case [(inst Prelude.span a) p xs']
                    (Prelude.MkPair (ys zs)
                      (isa (con Prelude.MkPair
                                (con Prelude.Cons x ys)
                                zs)
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a))))))
                (Prelude.False ()
                  (isa (con Prelude.MkPair
                            (con Prelude.Nil)
                            (con Prelude.Cons x xs'))
                       (con Prelude.Pair
                            (con Prelude.List a)
                            (con Prelude.List a)))))))))))
    
    
    (declare groupBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun (con Prelude.List a)
                  (con Prelude.List (con Prelude.List a))))))
    (define groupBy
      (abs a
        (lam eq (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List (con Prelude.List a))))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.span a) [eq x] xs']
                (Prelude.MkPair
                  (ys zs)
                  (isa (con Prelude.Cons
                            (con Prelude.Cons x ys)
                            [(inst Prelude.groupBy a) eq zs])
                       (con Prelude.List (con Prelude.List a)))))))))))
    
    
    (declare foldr
      (forall a (type) (forall b (type)
        (fun (fun a (fun b b))
             (fun b
                  (fun (con Prelude.List a)
                       b))))))
    (define foldr
      (abs a (abs b
        (lam c (lam n (lam xs
          (case xs
            (Prelude.Nil () n)
            (Prelude.Cons (x xs')
              [c x [(inst (inst Prelude.foldr a) b) c n xs']]))))))))
    
    
    (declare foldl
      (forall a (type) (forall b (type)
        (fun (fun b (fun a b))
             (fun b
                  (fun (con Prelude.List a)
                       b))))))
    (define foldl
      (abs a (abs b
        (lam s (lam n (lam xs
          (case xs
            (Prelude.Nil () n)
            (Prelude.Cons (x xs')
              [(inst (inst Prelude.foldl a) b) s [s n x] xs']))))))))
    
    
    (declare unfoldr
      (forall a (type) (forall b (type)
        (fun (fun b (con Prelude.Maybe (con Prelude.Pair a b)))
             (fun b (con Prelude.List a))))))
    (define unfoldr
      (abs a (abs b
        (lam step (lam s
          (case [step s]
            (Prelude.Nothing ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Just (p)
              (case p
                (Prelude.MkPair (x s')
                  (isa (con Prelude.Cons
                            x
                            [(inst (inst Prelude.unfoldr a) b) step s'])
                       (con Prelude.List a)))))))))))
    
    
    (declare replicate
      (forall a (type)
        (fun (integer) (fun a (con Prelude.List a)))))
    (define replicate
      (abs a
        (lam n (lam x
          (case [Prelude.equalsInteger n 0]
            (Prelude.True ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.False ()
              (isa (con Prelude.Cons
                        x
                        [(inst Prelude.replicate a)
                          [Prelude.subtractInteger n 1]
                          x])
                   (con Prelude.List a))))))))
    
    
    (declare map
      (forall a (type) (forall b (type)
        (fun (fun a b)
             (fun (con Prelude.List a) (con Prelude.List b))))))
    (define map
      (abs a (abs b
        (lam f (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List b)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Cons
                        [f x]
                        [(inst (inst Prelude.map a) b) f xs'])
                   (con Prelude.List b)))))))))
    
    
    (declare reverseOnto
      (forall a (type)
        (fun (con Prelude.List a)
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define reverseOnto
      (abs a
        (lam xs (lam ys
          (case xs
            (Prelude.Nil () ys)
            (Prelude.Cons (x xs')
              [(inst Prelude.reverseOnto a) xs' (con Prelude.Cons x ys)]))))))
    
    
    (declare reverse
      (forall a (type) (fun (con Prelude.List a) (con Prelude.List a))))
    (define reverse
      (abs a
        (lam xs [(inst Prelude.reverseOnto a) xs (con Prelude.Nil)])))
    
    
    (declare prependToAll
      (forall a (type)
        (fun a
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define prependToAll
      (abs a
        (lam sep (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Cons sep (con Prelude.Nil))
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Cons
                        sep
                        (con Prelude.Cons
                             x
                             [(inst Prelude.prependToAll a) sep xs']))
                   (con Prelude.List a))))))))
    
    
    (declare intersperse
      (forall a (type)
        (fun a
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define intersperse
      (abs a
        (lam sep (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Cons
                        x
                        [(inst Prelude.prependToAll a) sep xs'])
                   (con Prelude.List a))))))))
    
    
    (declare concat
      (forall a (type)
        (fun (con Prelude.List (con Prelude.List a))
             (con Prelude.List a))))
    (define concat
      (abs a
        (lam xss
          (case xss
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (xs xss')
              [(inst Prelude.append a) xs [(inst Prelude.concat a) xss']])))))
    
    
    (declare concatMap
      (forall a (type) (forall b (type)
        (fun (fun a (con Prelude.List b))
             (fun (con Prelude.List a)
                  (con Prelude.List b))))))
    (define concatMap
      (abs a (abs b
        (lam f (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List b)))
            (Prelude.Cons (x xs')
              [(inst Prelude.append b) [f x] [(inst (inst Prelude.concatMap a) b) f xs']])))))))
    
    
    (declare intercalate
      (forall a (type)
        (fun (con Prelude.List a)
             (fun (con Prelude.List (con Prelude.List a))
                  (con Prelude.List a)))))
    (define intercalate
      (abs a
        (lam xs (lam xss
          [(inst Prelude.concat a)
            [(inst Prelude.intersperse (con Prelude.List a))
              xs
              xss]]))))
    
    
    (declare filter
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define filter
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (isa (con Prelude.Cons x [(inst Prelude.filter a) p xs'])
                       (con Prelude.List a)))
                (Prelude.False () [(inst Prelude.filter a) p xs']))))))))
    
    
    (declare find
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Maybe a)))))
    (define find
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe a)))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (isa (con Prelude.Just x)
                       (con Prelude.Maybe a)))
                (Prelude.False () [(inst Prelude.find a) p xs']))))))))
    
    
    (declare partition
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Pair
                       (con Prelude.List a)
                       (con Prelude.List a))))))
    (define partition
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil))
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List a))))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.partition a) p xs']
                (Prelude.MkPair (ts fs)
                  (case [p x]
                    (Prelude.True ()
                      (isa (con Prelude.MkPair (con Prelude.Cons x ts) fs)
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a))))
                    (Prelude.False ()
                      (isa (con Prelude.MkPair ts (con Prelude.Cons x fs))
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a)))))))))))))
    
    
    (declare nubBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define nubBy
      (abs a
        (lam comp (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Cons
                        x
                        [(inst Prelude.filter a)
                          (lam y [Prelude.not [comp x y]])
                          [(inst Prelude.nubBy a) comp xs']])
                   (con Prelude.List a))))))))
    
    
    (declare zipWith
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun (con Prelude.List a)
                  (fun (con Prelude.List b)
                       (con Prelude.List c))))))))
    (define zipWith
      (abs a (abs b (abs c
        (lam f (lam xs (lam ys
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List c)))
            (Prelude.Cons (x xs')
              (case ys
                (Prelude.Nil ()
                  (isa (con Prelude.Nil)
                       (con Prelude.List c)))
                (Prelude.Cons (y ys')
                  (isa (con Prelude.Cons
                            [f x y]
                            [(inst (inst (inst Prelude.zipWith a) b) c)
                              f xs' ys'])
                       (con Prelude.List c)))))))))))))
    
    
    (declare zip
      (forall a (type) (forall b (type)
        (fun (con Prelude.List a)
             (fun (con Prelude.List b)
                  (con Prelude.List (con Prelude.Pair a b)))))))
    (define zip
      (abs a (abs b
        (lam xs (lam ys
          [(inst (inst (inst Prelude.zipWith a) b) (con Prelude.Pair a b)) (lam x (lam y (con Prelude.MkPair x y))) xs ys])))))
    
    
    (declare unzip
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Pair a b))
             (con Prelude.Pair (con Prelude.List a)
                               (con Prelude.List b))))))
    (define unzip
      (abs a (abs b
        (lam xys
          (case xys
            (Prelude.Nil ()
              (isa (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil))
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List b))))
            (Prelude.Cons (xy xys')
              (case xy
                (Prelude.MkPair (x y)
                  (case [(inst (inst Prelude.unzip a) b) xys']
                    (Prelude.MkPair (xs ys)
                      (isa (con Prelude.MkPair
                                (con Prelude.Cons x xs)
                                (con Prelude.Cons y ys))
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List b)))))))))))))
    
    
    (declare andList
      (fun (con Prelude.List (con Prelude.Bool)) (con Prelude.Bool)))
    (define andList
      (lam bs
        [(inst (inst Prelude.foldl (con Prelude.Bool)) (con Prelude.Bool))
          Prelude.and
          (con Prelude.True)
          bs]))
    
    
    (declare orList
      (fun (con Prelude.List (con Prelude.Bool)) (con Prelude.Bool)))
    (define orList
      (lam bs
        [(inst (inst Prelude.foldl (con Prelude.Bool)) (con Prelude.Bool))
          Prelude.or
          (con Prelude.False)
          bs]))
    
    
    (declare any
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Bool)))))
    (define any
      (abs a
        (lam p (lam xs [Prelude.orList [(inst (inst Prelude.map a) (con Prelude.Bool)) p xs]]))))
    
    
    (declare all
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Bool)))))
    (define all
      (abs a
        (lam p (lam xs [Prelude.andList [(inst (inst Prelude.map a) (con Prelude.Bool)) p xs]]))))
    
    
    (declare sumInteger
      (fun (con Prelude.List (integer)) (integer)))
    (define sumInteger
      (lam xs
        [(inst (inst Prelude.foldl (integer)) (integer))
          Prelude.addInteger 0 xs]))
    
    
    // (declare sumFloat
    //   (fun (con Prelude.List (float)) (float)))
    // (define sumFloat
    //   (lam xs [(inst (inst Prelude.foldl (float)) (float))
    //     Prelude.addFloat 0.0 xs]))
    
    (declare productInteger
      (fun (con Prelude.List (integer)) (integer)))
    (define productInteger
      (lam xs
        [(inst (inst Prelude.foldl (integer)) (integer))
          Prelude.multiplyInteger 1 xs]))
    
    
    // (declare productFloat
    //   (fun (con Prelude.List (float)) (float)))
    // (define productFloat
    //   (lam xs
    //     [(inst (inst Prelude.foldl (float)) (float))
    //       Prelude.multiplyFloat 1.0 xs]))
    
    (declare maximumBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun a
                  (fun (con Prelude.List a)
                       a)))))
    (define maximumBy
      (abs a
        (lam comp (lam m
          [(inst (inst Prelude.foldl a) a)
            (lam x (lam y
              (case [comp x y]
                (Prelude.True () y)
                (Prelude.False () x))))
            m]))))
    
    
    (declare minimumBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun a
                  (fun (con Prelude.List a)
                       a)))))
    (define minimumBy
      (abs a
        (lam comp (lam m
          [(inst (inst Prelude.foldl a) a)
            (lam x (lam y
              (case [comp x y]
                (Prelude.True () x)
                (Prelude.False () y))))
            m]))))
    
    
    (declare project
      (forall a (type)
        (fun (con Prelude.List a)
             (fun (integer)
                  (con Prelude.Maybe a)))))
    (define project
      (abs a
        (lam xs (lam n
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe a)))
            (Prelude.Cons (x xs')
              (case [Prelude.equalsInteger n 0]
                (Prelude.True ()
                  (isa (con Prelude.Just x)
                       (con Prelude.Maybe a)))
                (Prelude.False ()
                  [(inst Prelude.project a)
                    xs'
                    [Prelude.subtractInteger n 1]]))))))))
    
    
    (declare findIndex
      (forall a (type)
        (fun (fun a (con Prelude.Bool))
             (fun (con Prelude.List a)
                  (con Prelude.Maybe (integer))))))
    (define findIndex
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe (integer))))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (isa (con Prelude.Just 0)
                       (con Prelude.Maybe (integer))))
                (Prelude.False ()
                  (case [(inst Prelude.findIndex a) p xs']
                    (Prelude.Nothing ()
                      (isa (con Prelude.Nothing)
                           (con Prelude.Maybe (integer))))
                    (Prelude.Just (i)
                      (isa (con Prelude.Just [Prelude.addInteger i 1])
                           (con Prelude.Maybe (integer)))))))))))))
    
    
    (declare findIndicesFrom
      (forall a (type)
        (fun (integer)
             (fun (fun a (con Prelude.Bool))
                  (fun (con Prelude.List a)
                       (con Prelude.List (integer)))))))
    (define findIndicesFrom
      (abs a
        (lam i (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List (integer))))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (isa (con Prelude.Cons
                            i
                            [(inst Prelude.findIndicesFrom a)
                              [Prelude.addInteger i 1]
                              p
                              xs])
                       (con Prelude.List (integer))))
                (Prelude.False ()
                  [(inst Prelude.findIndicesFrom a)
                    [Prelude.addInteger i 1]
                    p
                    xs])))))))))
    
    
    (declare findIndices
      (forall a (type)
        (fun (con Prelude.List a)
             (fun (fun a (con Prelude.Bool))
                  (con Prelude.List (integer))))))
    (define findIndices
      (abs a
        (lam xs (lam p [(inst Prelude.findIndicesFrom a) 0 p xs]))))
    
    
    (declare evenOddSplitFrom
      (forall a (type)
        (fun (con Prelude.Bool)
             (fun (con Prelude.List a)
                  (con Prelude.Pair
                       (con Prelude.List a)
                       (con Prelude.List a))))))
    (define evenOddSplitFrom
      (abs a
        (lam b (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil))
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List a))))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.evenOddSplitFrom a) [Prelude.not b] xs']
                (Prelude.MkPair (es os)
                  (case b
                    (Prelude.True ()
                      (isa (con Prelude.MkPair (con Prelude.Cons x es) os)
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a))))
                    (Prelude.False ()
                      (isa (con Prelude.MkPair es (con Prelude.Cons x os))
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List a)))))))))))))
    
    
    (declare evenOddSplit
      (forall a (type)
        (fun (con Prelude.List a)
             (con Prelude.Pair
                  (con Prelude.List a)
                  (con Prelude.List a)))))
    (define evenOddSplit
      (abs a
        (lam xs [(inst Prelude.evenOddSplitFrom a) (con Prelude.True) xs])))
    
    
    (declare mergeBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun (con Prelude.List a)
                  (fun (con Prelude.List a)
                       (con Prelude.List a))))))
    (define mergeBy
      (abs a
        (lam comp (lam xs (lam ys
          (case xs
            (Prelude.Nil () ys)
            (Prelude.Cons (x xs')
              (case ys
                (Prelude.Nil ()
                  (isa (con Prelude.Cons x xs')
                       (con Prelude.List a)))
                (Prelude.Cons (y ys')
                  (case [comp x y]
                    (Prelude.True ()
                      (isa (con Prelude.Cons
                                x
                                [(inst Prelude.mergeBy a)
                                  comp
                                  xs'
                                  (con Prelude.Cons y ys')])
                           (con Prelude.List a)))
                    (Prelude.False ()
                      (isa (con Prelude.Cons
                                y
                                [(inst Prelude.mergeBy a)
                                  comp
                                  (con Prelude.Cons x xs')
                                  ys'])
                           (con Prelude.List a)))))))))))))
    
    
    (declare mergeSortBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define mergeSortBy
      (abs a
        (lam comp (lam xs
          (case [(inst Prelude.evenOddSplit a) xs]
            (Prelude.MkPair (es os)
              [(inst Prelude.mergeBy a)
                comp
                [(inst Prelude.mergeSortBy a) comp es]
                [(inst Prelude.mergeSortBy a) comp os]]))))))
    
    
    (declare quickSortBy
      (forall a (type)
        (fun (fun a (fun a (con Prelude.Bool)))
             (fun (con Prelude.List a)
                  (con Prelude.List a)))))
    (define quickSortBy
      (abs a
        (lam comp (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.partition a) [comp x] xs']
                (Prelude.MkPair (lo hi)
                  [(inst Prelude.append a)
                    [(inst Prelude.quickSortBy a) comp lo]
                    (con Prelude.Cons x [(inst Prelude.quickSortBy a) comp hi])]))))))))

    
    (declare listToMaybe
      (forall a (type)
        (fun (con Prelude.List a) (con Prelude.Maybe a))))
    (define listToMaybe
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (isa (con Prelude.Nothing)
                   (con Prelude.Maybe a)))
            (Prelude.Cons (x xs')
              (isa (con Prelude.Just x)
                   (con Prelude.Maybe a)))))))
    
    
    (declare maybeToList
      (forall a (type)
        (fun (con Prelude.Maybe a) (con Prelude.List a))))
    (define maybeToList
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Just (x)
              (isa (con Prelude.Cons x (con Prelude.Nil))
                   (con Prelude.List a)))))))
    
    
    (declare catMaybes
      (forall a (type)
        (fun (con Prelude.List (con Prelude.Maybe a))
             (con Prelude.List a))))
    (define catMaybes
      (abs a
        (lam ms
          (case ms
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (m ms')
              (case m
                (Prelude.Nothing () [(inst Prelude.catMaybes a) ms'])
                (Prelude.Just (x)
                  (isa (con Prelude.Cons x [(inst Prelude.catMaybes a) ms'])
                       (con Prelude.List a)))))))))
    
    
    (declare lefts
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             (con Prelude.List a)))))
    (define lefts
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List a)))
            (Prelude.Cons (e es')
              (case e
                (Prelude.Left (x)
                  (isa (con Prelude.Cons x [(inst (inst Prelude.lefts a) b) es'])
                       (con Prelude.List a)))
                (Prelude.Right (y) [(inst (inst Prelude.lefts a) b) es']))))))))
    
    
    (declare rights
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             (con Prelude.List b)))))
    (define rights
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (isa (con Prelude.Nil)
                   (con Prelude.List b)))
            (Prelude.Cons (e es')
              (case e
                (Prelude.Left (x) [(inst (inst Prelude.rights a) b) es'])
                (Prelude.Right (y)
                  (isa (con Prelude.Cons y [(inst (inst Prelude.rights a) b) es'])
                       (con Prelude.List b))))))))))
    
    
    (declare partitionEithers
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             (con Prelude.Pair
                  (con Prelude.List a)
                  (con Prelude.List b))))))
    (define partitionEithers
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (isa (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil))
                   (con Prelude.Pair
                        (con Prelude.List a)
                        (con Prelude.List b))))
            (Prelude.Cons (e es')
              (case [(inst (inst Prelude.partitionEithers a) b) es']
                (Prelude.MkPair (ls rs)
                  (case e
                    (Prelude.Left (x)
                      (isa (con Prelude.MkPair (con Prelude.Cons x ls) rs)
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List b))))
                    (Prelude.Right (y)
                      (isa (con Prelude.MkPair ls (con Prelude.Cons y rs))
                           (con Prelude.Pair
                                (con Prelude.List a)
                                (con Prelude.List b)))))))))))))
    
    
    
    //
    // Blockchain Tools
    //
    
    
    // (declare verifySignature
    //   (fun (bytestring)
    //     (fun (bytestring)
    //       (fun (bytestring)
    //            (con Prelude.Bool)))))
    // (define verifySignature
    //   (lam k (lam dat (lam s
    //     (builtin verifySignature k dat s)))))
    // 
    // 
    // (declare verify
    //   (fun (bytestring)
    //        (fun (bytestring)
    //             (fun (con Prelude.Maybe (bytestring))
    //                  (con Prelude.Bool)))))
    // (define verify
    //   (lam dat (lam k (lam m
    //     (case m
    //       (cl Prelude.Nil () (con Prelude.False))
    //       (cl Prelude.Just (s) [verifySignature k dat s]))))))
    // 
    // 
    // (declare verifyMultiSig
    //   (fun (integer)
    //     (fun (con Prelude.List (bytestring))
    //       (fun (bytestring)
    //         (fun (con Prelude.List (con Prelude.Maybe (bytestring)))
    //           (comp (con Prelude.Unit)))))))
    // (define verifyMultiSig
    //   (lam n (lam keys (lam dat (lam sigs
    //     (case [Prelude.and
    //             [equalsInt
    //               [(inst Prelude.length (con Prelude.List (bytestring))) keys]
    //               [(inst Prelude.length (con Prelude.List (con Prelude.Maybe (bytestring)))) sigs]]
    //             [Prelude.lessThanEqualsInt
    //               n
    //               [(inst Prelude.length (con Prelude.Bool))
    //                 [(inst Prelude.filter (con Prelude.Bool)) (inst id Prelude.Bool)
    //                   [(inst (inst (inst Prelude.zipWith (bytestring)) (con Prelude.Maybe (bytestring))) (con Prelude.Bool))
    //                     [Prelude.verify dat]
    //                     keys
    //                     sigs]]]]]
    //       (Prelude.True () (success (con Prelude.MkUnit)))
    //       (Prelude.False () (failure))))))))
    
    
    (data MASTProp ()
      (MASTTrue)
      (MASTFalse)
      (MASTNot (con Prelude.MASTProp))
      (MASTAnd (con Prelude.MASTProp) (con Prelude.MASTProp))
      (MASTOr (con Prelude.MASTProp) (con Prelude.MASTProp)))
    
    
    (declare evalMASTProp
      (fun (con Prelude.MASTProp) (con Prelude.Bool)))
    (define evalMASTProp
      (lam m
        (case m
          (Prelude.MASTTrue () (isa (con Prelude.True) (con Prelude.Bool)))
          (Prelude.MASTFalse () (isa (con Prelude.False) (con Prelude.Bool)))
          (Prelude.MASTNot (x) [Prelude.not [Prelude.evalMASTProp x]])
          (Prelude.MASTAnd (x y)
            [Prelude.and [Prelude.evalMASTProp x] [Prelude.evalMASTProp y]])
          (Prelude.MASTOr (x y)
            [Prelude.or [Prelude.evalMASTProp x] [Prelude.evalMASTProp y]]))))
    
    
    (data MASTTree ()
      (MASTSuccess)
      (MASTFailure)
      (MASTIf (con Prelude.MASTProp)
              (con Prelude.MASTTree)
              (con Prelude.MASTTree)))
    
    
    (data MASTPath ()
      (MASTPathSuccess)
      (MASTPathFailure)
      (MASTPathIfTrue (con Prelude.MASTProp)
                      (con Prelude.MASTPath)
                      (bytestring))
      (MASTPathIfFalse (con Prelude.MASTProp)
                       (bytestring)
                       (con Prelude.MASTPath)))
    
    
    (declare evalMASTPath
      (fun (con Prelude.MASTPath) (con Prelude.Bool)))
    (define evalMASTPath
      (lam m
        (case m
          (Prelude.MASTPathSuccess () (isa (con Prelude.True) (con Prelude.Bool)))
          (Prelude.MASTPathFailure () (isa (con Prelude.False) (con Prelude.Bool)))
          (Prelude.MASTPathIfTrue (test t f)
            (case [Prelude.evalMASTProp test]
              (Prelude.True () [Prelude.evalMASTPath t])
              (Prelude.False ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))))
          (Prelude.MASTPathIfFalse (test t f)
            (case [Prelude.evalMASTProp test]
              (Prelude.True ()
                (isa (con Prelude.False)
                     (con Prelude.Bool)))
              (Prelude.False () [Prelude.evalMASTPath f]))))))
    
    
    (declare hashMASTProp
      (fun (con Prelude.MASTProp) (bytestring)))
    (define hashMASTProp
      (lam m
        (case m
          (Prelude.MASTTrue () #00)
          (Prelude.MASTFalse () #01)
          (Prelude.MASTNot (x)
            [Prelude.sha2_256
              [Prelude.concatenate #02 [Prelude.hashMASTProp x]]])
          (Prelude.MASTAnd (x y)
            [Prelude.sha2_256
              [Prelude.concatenate #03
                [Prelude.concatenate
                  [Prelude.hashMASTProp x]
                  [Prelude.hashMASTProp y]]]])
          (Prelude.MASTOr (x y)
            [Prelude.sha2_256
              [Prelude.concatenate #04
                [Prelude.concatenate
                  [Prelude.hashMASTProp x]
                  [Prelude.hashMASTProp y]]]]))))
    
    
    (declare hashMASTTree
      (fun (con Prelude.MASTTree) (bytestring)))
    (define hashMASTTree
      (lam m
        (case m
          (Prelude.MASTSuccess () #00)
          (Prelude.MASTFailure () #01)
          (Prelude.MASTIf (test t f)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  [Prelude.hashMASTTree t]
                  [Prelude.hashMASTTree f]]]]))))
    
    
    (declare hashMASTPath
      (fun (con Prelude.MASTPath) (bytestring)))
    (define hashMASTPath
      (lam m
        (case m
          (Prelude.MASTPathSuccess () #00)
          (Prelude.MASTPathFailure () #01)
          (Prelude.MASTPathIfTrue (test t fhash)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  [Prelude.hashMASTPath t]
                  fhash]]])
          (Prelude.MASTPathIfFalse (test thash f)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  thash
                  [Prelude.hashMASTPath f]]]]))))
    
    
    (declare checkMAST
      (fun (bytestring)
           (fun (con Prelude.MASTPath)
                (con Prelude.Bool))))
    (define checkMAST
      (lam hash (lam path
        (case [Prelude.evalMASTPath path]
          (Prelude.False ()
            (isa (con Prelude.False)
                 (con Prelude.Bool)))
          (Prelude.True ()
            [Prelude.equalsByteString
              hash
              [Prelude.hashMASTPath path]])))))))