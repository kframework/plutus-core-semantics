Execution
=========

- Check if [test/execution/import-nonexistent.expected] should get stuck?

Translation: Generation of top level functions
==============================================

Top level `define`d lambda can be used in two ways.

1. They can be called with one argument (application)
2. They can be passed to another lambda.

There are two ways I can think of:

1. Generate multiple functions with different number of args
2. Generate multiple entries in the dispatch table

Generate multiple functions with different number of args
---------------------------------------------------------

We must generate

1. A function that takes (an evironment) plus one argument   and returns whatever the lambda returns.
2. A function that takes (an evironment) plus zero arguments and returns a closure.
   (this could be optimized to be a global that points to the closure generated
   at compile time though).

Additionally, if the lambda is public, and is `n` parameters deep, we
must additionally generate a function that takes `n` parameters and
returns wherever.

TODO: How would this code look?
????: Is this really different? Won't we just have the same number of dispatch
enteries and n functions too?

Generate multiple entries in the dispatch table
-----------------------------------------------

However, we can unify these three cases if we move the marshalling and
demarshalling of these functions into `@dispatch`.
For an lambda `n` levels deep, we generate a single function that takes `n` arguments
along with `n+1` entries in the dispatch table for each arity of the generated functions.

For example:

    (define add          (lam x (lam y (x + y)))
    (define twice (lam f (lam x (lam y ([f [[f x] y] y])))
    (define addTwice     (lam x (lam y ([[[twice add] x] y])))

becomes:

    // jumpId = 1
    function add(%x, %y) {
        %ret = add %x %y
        ret %ret
    }

    // jumpId = 2
    function twice(%f, %x, %y) {
    // #loadOp [f x]
        %f.ptr = load %f
        %app1 = call dispatch1(%f.ptr, %x)
    // #loadOp [_ y]
        %app2 = call dispatch1(%app1, y)
    // #loadOp [_ y]
        %app3 = call dispatch1(%app2, y)
        ret %app3
    }

    // jumpId = 3
    function addTwice(%x, %y) {
     // #loadOp "twice"
        %twice = @dispatch0(2)
     // #loadOp "add"
        %add = @dispatch0(1)
     // #loadOp [twice add]
        %app1 = @dispatch1(%twice, %add)
     // #loadOp [_ x]
        %app2 = @dispatch1(%app1, %x)
     // #loadOp [_ y]
        %app3 = @dispatch1(%app3, %y)
        ret %app3
    }

    function dispatch0(%closure) {
        ...
        // Maybe we can optimize dispatch0 as the fptr itself being the closure.
        // For a closure of `n` arguments, this would generalize to a linked list
        // of size `n` starting from the last argument to the first, simplifying
        // garbage collection etc???
    }

    function dispatch1(%closure, %param) {
        %clId = load %closure

        // if %closure[0] == 1.1 jump callAdd
        %cond = cmp eq %clID #closureId(callAdd)
        jmp callAdd %cond
        // if %closure[0] == 2.2 jump callTwice
        ...
        // if %closure[0] == 3.1 jump callAddTwice
        ...

        callAdd:
            %closure = add %closure 1
            %1 =     = load %closure
            ret call add(%1, %param)
        callTwice:
            %closure = add %closure 1
            %1 =     = load %closure
            %closure = add %closure 1
            %2 =     = load %closure
            ret call add(%1, %2, %param)
        callAddTwice:   ret call addTwice(fptr[1], %param)
 }
